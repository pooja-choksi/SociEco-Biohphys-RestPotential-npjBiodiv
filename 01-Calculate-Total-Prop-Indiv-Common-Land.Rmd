---
title: "People-centric Restoration: Assigning Different Land Tenures based on Land Uses"
author: "Pooja Choksi"
date: "2022-06-03"
output: html_document
--

# LAND USE-BASED TENURE ASSINGMENTS FOR INDIAN VILLAGES

This dataset has been created using the Census 2011 land use records. The resords have been assigned tenures based on commonly accepted land tenure regimes across India. Details on the dataset can be found here: https://docs.google.com/document/d/1QS1E9VQGWX0HaQfXfcDWlG7fv6kZJn7oYxvjMaaQnF4/edit?usp=sharing

We retrieved land use records from Census 2011(https://censusindia.gov.in/2011census/dchb/DCHB.html) for every district in the states and Union territories of India. We manually created csv files for each district within each state. To do so, we only selected the following columns of our interest in the land use records. From the data downloaded, For each village with a census code, the columns we selected are:
1. Total population 
2. Total number of households 
3. Total area in hectares
4. Land-use data (with a total of ten categories of land uses included) 

Land use categories in Census 2011: 
1. Forest 
2. Area under non-agricultural use 
3. Barren or uncultivable land 
4. Permanent pastures or grazing lands
5. Land under misc tree crops (orchards)
6. Culturable Wasteland
7. Fallow lands other than current fallow
8. Current fallow land 
9. Net Sown Area
10. Total irrigated land 
11. Total unirrigated land 

In the following code chunk, we combine and clean all the data from individual districts to create one country wide land use dataset. 

```{r include = FALSE}

library(data.table)
library(dplyr)
library(tidyr)
library(htmltools)
library(rmarkdown)
library(stringr)
library(ggplot2)

```

```{r message = FALSE, warning = FALSE}


#Combining data from all the states
dat.summary.original = sapply(list.files(path="C:\\Users\\pooja\\Documents\\GitHub\\Land-Tenure-Restoration-Potential\\Land-Tenure-Restoration-Potential\\Census2011-landUse-CSVFiles\\Sheets_For_Analysis",recursive=T, #looping through each subfolder for state
  pattern="_Census2011_LandUse.csv",full.names=T), function(file) {df = read.csv(file, stringsAsFactors=FALSE, colClasses=c(Village_name= "character",
                              Census_Code = "character",
                              District_Name = "character",
                              Subdistrict_Block="character",
                              Total_Population = "integer",
                              Total_Household= "integer",
                              Total_area_in_hectares="numeric",
                              forests_land ="numeric",
                              non_agricultural_land="numeric",
                              barren_uncultivable_land="numeric",
                              pasture_grazing_land="numeric",
                              misc_tree_crop_land="numeric",
                              culturable_wasteland="numeric",
                              fallow_other_than_current_fallow_land= "numeric",
                              current_fallow_land="numeric",
                              net_sown_area="numeric",
                              total_irrigated_land="numeric",
                              total_unirrigated_land="numeric",
                              State ="character"), header=TRUE)})

#Combine all rows 
dat.summary = bind_rows(dat.summary.original)

```

```{r include = FALSE}

#Issue with the village name column 
colnames(dat.summary)
dat.summary = dat.summary%>%mutate(Village_name = coalesce(Village_name, ï..Village_name))

#dat.summary = dat.summary%>%mutate(Village_name = coalesce(Village_name, Ã...Village_name))

#Remove extra rows (numbering issue)
dat.summary = subset(dat.summary, select = -c(X, ï..Village_name))

#drop any empty rows
filter_1 = dat.summary%>%filter(Village_name == "")
dat.summary = anti_join(dat.summary, filter_1)

#State names may differ due to spaces etc 
dat.summary = dat.summary%>%dplyr::mutate(State = recode(State, 
                                                         "Arunachal_Pradesh" = "Arunachal Pradesh", 
                                                         "karnataka" = "Karnataka",
                                                         "Madhya_Pradesh  " = "Madhya Pradesh",
                                                         "Madya Pradesh " = "Madhya Pradesh",
                                                         "Madhya Pradesh " = "Madhya Pradesh",
                                                         "Uttar_Pradesh" = "Uttar Pradesh", 
                                                         "Uttar Pradesh " = "Uttar Pradesh"))

unique(dat.summary$State)
#you should have 35 unique states and UT

#there is an error in Basti district - the state should be Uttar Pradesh, but the csv says Odisha
dat.summary = within(dat.summary, State[District_Name %in% c("Basti")]<-"Uttar Pradesh")

#Remove duplicates due to copying errors in manual extraction of land use data
duplicates = dat.summary[duplicated(dat.summary$Census_Code), ]
dat.summary = anti_join(dat.summary, duplicates)

```


CLEANING INCONSISTENCIES IN THE DATA

In the following chunk of code, we deal with the incosistencies in the data such as the difference in totals of all land uses and the reported total area of a village in hectares. Most importantly, there is often 'unaccounted' land, which has to be considered in the total area to calculate different land tenures.

```{r message = FALSE, warning = FALSE}

#Mismatch in total hectares of land#
##Is total hectares = land use categories?

#a. total up the land uses we considered to make prop land tenure above
dat.summary = dat.summary %>%
  mutate(Total_land_uses = select(., forests_land:net_sown_area) %>% rowSums(na.rm = TRUE))

#b. check if total_hectares from census data match the total of land uses calculated in (a)
dat.summary = dat.summary%>%mutate(Totals_Match = 
                                     case_when(Total_area_in_hectares == Total_land_uses ~ "Match",TRUE~ "No_Match"))

#c. check if the match is > 2 hectares (we allow for 2 hectare difference due to rounding off and differences in int and num values across diff subdistricts/districts/states)
dat.summary = dat.summary%>%mutate(Difference_in_totals = Total_area_in_hectares- Total_land_uses)

#d. create column of 'unaccounted' land in records 
dat.summary = dat.summary%>%mutate(Unaccounted_hectares_in_records =
                                     case_when(Difference_in_totals>0 ~ Difference_in_totals, 
                                               TRUE ~ 0))


#d. use the new total no. of hectares if old total is not equal to total of land uses 
dat.summary = dat.summary%>%mutate(Total_hectares_for_prop = case_when(
  #if village didn't report total, use total of land uses
  (Total_area_in_hectares == 0 & Total_land_uses>0)~ (Total_land_uses+Unaccounted_hectares_in_records), 
  #if village total land use is greater than total area reported
  (Total_area_in_hectares< Total_land_uses)~ (Total_land_uses+Unaccounted_hectares_in_records),
  #allow 2 hectares of a difference in totals due to rounding off/diff method of addition
  (Difference_in_totals < -2) ~ (Total_land_uses+Unaccounted_hectares_in_records), 
  #Total_area_in_hectares != Total_land_uses ~Total_land_uses, 
  TRUE~ Total_area_in_hectares))

# Filter out the no_match from (d)
#Use the differences file to further clean data 
differences = dat.summary%>%filter(Difference_in_totals>2 | Difference_in_totals< -2)
difference_positive = dat.summary%>%filter(Difference_in_totals>2)
difference_negative = dat.summary%>%filter(Difference_in_totals< -2)

#Round all numeric data to 3 digits 
dat.summary = dat.summary %>% 
  mutate(across(where(is.numeric), ~ round(., digits = 3)))

```

CALCULATING TOTAL AREA IN A VILLAGE

In this chunk of code we calculate the total area of land in a village in different land tenures as well as the proportion of land tenures in each village. We do after we remove state-owned forests and calculate total hectares of land for each land tenure and the proportion of each land tenure in the village. 

Below are more details on the different kinds of villages we had to remove from the dataset for our analysis:
  
1. Inconsistencies in the data:
We encountered 4 types of inconsistencies with the land use records. Below are the inconsistencies we encountered in the data and the steps taken to note them. 

2. State-owned forests:
As state owned land also receive census codes, we filtered out as many types of state owned land as possible to remove from this analysis. After filtering out potential state-owned land from the land-use records, we have the final dataset of Census 2011villages to be considered in this analysis.

3. Un-inhabited villages:
We filtered villages which were labelled ‘uninhabited’ by the Census of 2011. Below are the details of the villages filtered out on account of being officially un-inhabited. 

4. Zero population villages:
We have considered villages with a population of zero, as they have land use records. We assume that these villages are either un-inhabited as they are farm land or other land use owned by neighbouring villages or the Census 2011 enumerators were unable to reach them. As these villages have a land-use record, we considered them in our analysis. Below are the states in which we found villages with zero population. 

With all the data that remained, we calculated the total number of hectares in each category of land tenure- common non-forest land, common forest land, individual land, unaccounted land tenure.

```{r message = FALSE, warning = FALSE}

##Uninhabited villages
#Filter all files with total population zero
population_zero = dat.summary%>%filter(Total_Population == 0)
uninhabited_village = dat.summary%>%filter(str_detect(Village_name, "Un-inhabited"))

dat.summary = anti_join(dat.summary, population_zero)
dat.summary = anti_join(dat.summary, uninhabited_village)

#####Forest blocks#####
forest_village_name = dat.summary%>%filter(str_detect(Village_name, "Beat| Block|Forest|Camp| Reserve | Range | Gate| K.M.| Department"))
dat.summary = anti_join(dat.summary, forest_village_name)

forest_block = dat.summary%>%filter(str_detect(Subdistrict_Block, "Beat| Block|Forest|Camp| Reserve | Range | Gate| K.M."))
dat.summary = anti_join(dat.summary, forest_block)

forest_district = dat.summary%>%filter(str_detect(District_Name, "Beat| Block|Forest|Camp| Reserve | Range | Gate| K.M."))
#none of the disticts are forests

#####No land use data#####
no_landuse_data = dat.summary%>%filter(Total_hectares_for_prop == 0)
dat.summary = anti_join(dat.summary, no_landuse_data)

#Total number of hectares of different land tenures 
# Summarise landuse per village 

dat.summary = dat.summary %>% dplyr::mutate(Total_Indiv = (net_sown_area+ current_fallow_land+ fallow_other_than_current_fallow_land), 
Total_Common = (non_agricultural_land+ barren_uncultivable_land+ pasture_grazing_land+ misc_tree_crop_land+ culturable_wasteland), 
                                     Total_Forest = forests_land,
                                     Total_Unaccounted = Unaccounted_hectares_in_records)

#Proportion of land tenures
# Summarise landuse per village 
dat.summary = dat.summary %>% dplyr::mutate(Prop_Indiv = ((net_sown_area+ current_fallow_land+ fallow_other_than_current_fallow_land)/Total_hectares_for_prop)*100,  Prop_Common = ((non_agricultural_land+ barren_uncultivable_land+ pasture_grazing_land+ misc_tree_crop_land+ culturable_wasteland)/Total_hectares_for_prop)*100, 
Prop_Forest = (forests_land/Total_hectares_for_prop)*100,
                                     Prop_Unaccounted = (Unaccounted_hectares_in_records/Total_hectares_for_prop)*100)

#Round all numeric data to 3 digits 
dat.summary = dat.summary %>% 
  mutate(across(where(is.numeric), ~ round(., digits = 3)))
  
```

Before creating the final dataset clean the datasheet.

```{r message=FALSE, warning=FALSE,include = TRUE}
#There is a spelling mistake in some district names

#Recode district names  
dat.summary = dat.summary%>%dplyr::mutate(District_Name = recode(District_Name, 
                                                     "Ragarh " = "Rajgarh",
                                                     "Rajgarh " = "Rajgarh",
                                                     "Indore " = "Indore",
                                                     "Sehore " = "Sehore",
                                                     "Barwani " = "Barwani",
                                                     "Papum Pare" = "Papumpare"))


#Change some districts from Andhra to Telangana since they now fall in the newly created state
dat.summary = dat.summary%>%mutate(State = case_when(District_Name == 
                                                 "Adilabad"~ "Telangana",
District_Name == "Karimnagar" ~ "Telangana",
District_Name ==  "Khammam"~"Telangana",
District_Name =="Mahbubnagar"~ "Telangana",
District_Name =="Medak"~ "Telangana",
District_Name =="Nalgonda"~"Telangana",
District_Name =="Nizamabad"~ "Telangana",
District_Name =="Rangareddy"~ "Telangana",
District_Name =="Warangal"~"Telangana",
TRUE ~ State))

```

```{r include = FALSE}

write.csv(dat.summary, "All-State-LandUse-Combined.csv")

```
