---
title: "People-centric restoratrion: Optimizing human development variables and land tenure"
author: "Pooja Choksi"
date: '2022-06-03'
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(forcats)
library(dplyr)
library(qcc)
library(gridExtra)

```

PEOPLE-CENTRIC RESTORATION: MAXIMISING HUMAN DEVELOPMENT AND ADDRESSING VULNERABILITY

## QUESTION 1: 
Where are the districts which would provide the maximum benefit when considering the following variables: (1) max population, (2) Multidimensional poverty index and (3) climate vulnerability, (4) total number of hectares available for restoration? 

Working on the assumption that ecological restoration is beneficial for natural resources dependent livelihoods, we quantify people-centric restoration potential of different land tenure regimes and states to meet human development needs, using public land use data. 

(1) TOTAL POPULATION:

In the following chunk of code, we plot the total population and cumulative population at a district and state level.

```{r message= FALSE, warning= FALSE, include=TRUE}

#Read in land use data
dat.summary = read.csv("All-State-LandUse-Combined.csv")

#In this dataset the newly created state Telangana 
dat.summary$State[which(dat.summary$District_Name == c("Adilabad", 
                                                       "Karimnagar",
                                                       "Khammam",
                                                       "Mahbubnagar",
                                                       "Medak",
                                                       "Nalgonda",
                                                       "Nizamabad",
                                                       "Rangareddy",
                                                       "Warangal"))] <- "Telangana"


#State total stacked area plot
state_summary = dat.summary%>%group_by(State)%>%summarise_at(.vars =
vars(Total_Indiv, Total_Common, Total_Forest, Total_Unaccounted,Total_Population),
.funs =c(sum = "sum"))

#rearrange tenure common in descending order
state_summary <- state_summary[order(state_summary$Total_Population_sum, decreasing=TRUE),]

#add cumulative column to the data frame
state_summary[,"cum_indiv_hectares"] <- cumsum(state_summary$Total_Indiv_sum)
state_summary[,"cum_common_hectares"] <- cumsum(state_summary$Total_Common_sum)
state_summary[,"cum_forest_hectares"] <- cumsum(state_summary$Total_Forest_sum)
state_summary[,"cum_unaccounted_hectares"] <- cumsum(state_summary$Total_Unaccounted_sum)
state_summary[,"cum_total_population"] <- cumsum(state_summary$Total_Population_sum)

#plot in descending order#assign order to prop variable
prop_order <-
  state_summary %>%
  arrange(desc(Total_Population_sum)) %>%
  mutate(State = factor(State))

#plot decreasing pop and cumulative hectares 
scaleRight = 5

population_max  = state_summary%>%mutate(State = factor(State, levels= prop_order$State, ordered =TRUE))%>%
  ggplot(aes(x = State, y = Total_Population_sum))+ 
  geom_col(aes(x = State, y = Total_Population_sum), fill = "#D3D3D3") + 
    #geom_line(aes(x = State, y= cum_hectares, group = 1)) + 
  geom_line(aes(y= cum_total_population/scaleRight), group = 1, color = "black", size = 1.2)+ 
  #geom_point(aes(y= cum_indiv_hectares/scaleRight), group = 1, color = "#E69F00")+ 
  #geom_line(aes(y= cum_common_hectares/scaleRight), group = 1, color = "#999933", size = 1.2)+ 
  #geom_point(aes(y= cum_common_hectares/scaleRight), group = 1, color = "#999933")+ 
  #geom_line(aes(y= cum_forest_hectares/scaleRight), group = 1, color = "#117733", size = 1.2)+ 
  #geom_point(aes(y= cum_forest_hectares/scaleRight), group = 1, color = "#117733")+
  scale_y_continuous(name = "Total Population (in Millions)", sec.axis = sec_axis(~.*scaleRight, name="Cumulative Population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)), labels = scales::label_number(unit = "M", scale = 1e-6))+
  theme_classic()+ theme(axis.title = element_text(size = 8), axis.text.x = element_text(angle = 45, hjust = 1, size = 8))

population_max

```

(2) MULTIDIMENSIONALLY POOR POPULATION

In this chunk of code, we quantify the restoration prioritization based on the number of multidimensionally poor people there are in a district or state

```{r message = FALSE, warning=FALSE, include = FALSE}

#Read in the MPI data
mpi_district = read.csv("Multidimensional_Poverty_Index_2018.csv")

#ensure names of districts and states match in mpi and dat.summary 
conflict_state = mpi_district[!mpi_district$State %in% dat.summary$State, ]
unique(conflict_state$State)

#change State names to match dat.summary 
mpi_district = mpi_district%>%dplyr::mutate(State = recode(State, "Andaman And Nicobar Islands" = "Andaman Nicobar UT","Daman And Diu" = "Daman Diu",
                                                           "Delhi" = "NCT_Delhi",
                                                         "Jammu And Kashmir" = "Jammu Kashmir",
                                                         "Dadra And Nagar Haveli" = "Dadra Nagarhaveli UT",
                                                         "Tamil Nadu" = "Tamil_Nadu",
                                                         "West Bengal" = "West_Bengal"))

#check again
conflict_state = mpi_district[!mpi_district$State %in% dat.summary$State, ]
unique(conflict_state$State)
#the states/ UTS that remain as conflict are those that do not have ;land use data and were removed in script 1 - Meghalaya. Mizoram, Puducherry

#here we filter them out to remove from analysis
to_remove = mpi_district%>%filter(State == c("Meghalaya", "Mizoram", "Puducherry"))
mpi_district = anti_join(mpi_district, to_remove)

#Join mpi and dat.summary using state and district names
trial = merge(dat.summary, mpi_district[c("District", "State", "MPI_District", "Number_of_MPI_PeopleDistrict")], by.x = c("State", "District_Name"), 
              by.y= c("State", "District"))

#find the districts with no match between mpi and dat.summary 
conflict_obs = mpi_district[!mpi_district$District %in% trial$District_Name, ]

#Filter our districts frmo dat.summary to check for inconsistencies in spelling
arunachal = dat.summary%>%filter(State == "Arunachal Pradesh")
unique(arunachal$District_Name)

Chhattisgarh = dat.summary%>%filter(State == "Chhattisgarh")
unique(Chhattisgarh$District_Name)

nct_delhi = dat.summary%>%filter(State == "NCT_Delhi")
unique(nct_delhi$District_Name)

gujarat = dat.summary%>%filter(State == "Gujarat")
unique(gujarat$District_Name)

himachal = dat.summary%>%filter(State == "Himachal Pradesh")
unique(himachal$District_Name)

Jharkhand = dat.summary%>%filter(State == "Jharkhand")
unique(Jharkhand$District_Name)

jammu = dat.summary%>%filter(State == "Jammu Kashmir")
unique(jammu$District_Name)

Madhya_Pradesh = dat.summary%>%filter(State == "Madhya Pradesh")
unique(Madhya_Pradesh$District_Name)

Maharashtra = dat.summary%>%filter(State == "Maharashtra")
unique(Maharashtra$District_Name)

Manipur = dat.summary%>%filter(State == "Manipur")
unique(Manipur$District_Name)

Meghalaya = dat.summary%>%filter(State == "Meghalaya")
unique(Manipur$District_Name)

Manipur = dat.summary%>%filter(State == "Manipur")
unique(Manipur$District_Name)

Mizoram = dat.summary%>%filter(State == "Mizoram")
unique(Mizoram$District_Name)

Nagaland = dat.summary%>%filter(State == "Nagaland")
unique(Nagaland$District_Name)

Punjab = dat.summary%>%filter(State == "Punjab")
unique(Punjab$District_Name)

sikkim = dat.summary%>%filter(State == "Sikkim")
unique(sikkim$District_Name)

tamil_nadu = dat.summary%>%filter(State == "Tamil_Nadu")
unique(tamil_nadu$District_Name)

uttar_pradesh = dat.summary%>%filter(State == "Uttar Pradesh")
unique(uttar_pradesh$District_Name)

uttarakhand = dat.summary%>%filter(State == "Uttarakhand")
unique(uttarakhand$District_Name)

west_bengal = dat.summary%>%filter(State == "West_Bengal")
unique(west_bengal$District_Name)

andhra = dat.summary%>%filter(State == "Andhra Pradesh")
unique(andhra$District_Name)

#Recode district names to match dat.summary 
mpi_district = mpi_district%>%dplyr::mutate(District = recode(District, 
                                                     "Uttar Bastar Kanker" = "Uttar_Bastar_Kanker",
                                                     "Janjgir - Champa" = "Janjgir_Champa",
                                                         "Kabirdham" = "Kabeerdham",
                                                         "Korea (Koriya)" = "Koriya",
                                                         "North East" = "North_East",
                                                     "North West" = "North_West",
                                                     "South West" = "South_West",
                                                     "Panchmahal" = "Panch Mahals",
                                                     "Sabarkantha" = "Sabar Kantha",
                                                     "Banaskantha" = "Banas Kantha",
                                                     "Leh" = "Leh(Ladakh)",
                                                         "Lahul And Spiti" = "Lahul & Spiti",
                                                     "Pashchimi Singhbhum" = "Pashchimi_Singhbhum",
                                                     "Purbi Singhbhum"= "Purbi_Singhbhum", 
                                                     "Saraikela Kharsawan" = "Saraikela_Kharsawan", 
"Dhar" = "Dhar ", 
"North  District"= "North District",
"The Nilgiris" = "The_Nilgiris", 
"Kanshiram Nagar" = "Kanshiram_Nagar",
"Sant Kabir Nagar" = "Sant_Kabir_Nagar",
"Sant Ravidas Nagar (Bhadohi)" = "Sant_Ravidas_Nagar_(Bhadohi)",
"Siddharth Nagar" = "Siddharthnagar",
"Tehri Garhwal" = "Tehri_Garhwal",
"Udham Singh Nagar" = "Udham_Singh_Nagar",
"Dakshin Dinajpur" = "Dakshin_Dinajpur", 
"Koch Bihar" = "Koch_Bihar ",
"North Twenty Four Parganas" = "North_Twenty_Four_Parganas",
"Paschim Medinipur" = "Paschim_Medinipur",
"Purba Medinipur" = "Purba_Medinipur", 
"South Twenty Four Parganas" = "South_Twenty_Four_Parganas", 
"Uttar Dinajpur" = "Uttar_Dinajpur"))

#Join mpi and dat.summary using state and district names
mpi_dat.summary = merge(dat.summary, mpi_district[c("District", "State", "MPI_District", "Number_of_MPI_PeopleDistrict")], by.x = c("State", "District_Name"), by.y= c("State", "District"))

#find the districts with no match between mpi and dat.summary 
conflict_obs = mpi_district[!mpi_district$District %in% mpi_dat.summary$District_Name, ]

#the 38 conflict obs that remain are only metropolitan areas/ towns (with no land use data), other districts (e.g.: Arunachal Pradesh) with no land use data available from census 2011 records and one new district in UP (Basti) for which there is no land use data. 

```

```{r message = FALSE, warning=FALSE, include = TRUE}

#District summary of variables of interest
district_summary = dat.summary%>%group_by(District_Name, State)%>%summarise_at(.vars =vars(Total_Indiv, Total_Common, Total_Forest, Total_Unaccounted),
.funs =c(sum = "sum"))

#Combine this table with the mpi table
mpi_district_summary = merge(district_summary, mpi_district[c("District", "State", "MPI_District", "Number_of_MPI_PeopleDistrict")], by.x = c("State", "District_Name"), by.y= c("State", "District"))

#Aggregate to state 
mpi_state_summary = mpi_district_summary%>%group_by(State)%>%mutate(
  Total_mpi_poor = sum(Number_of_MPI_PeopleDistrict))
  
mpi_state_summary = mpi_state_summary%>%group_by(State, Total_mpi_poor)%>%summarise_at(.vars =vars(Total_Indiv_sum, Total_Common_sum, Total_Forest_sum, Total_Unaccounted_sum), .funs =c(sum = "sum"))

#rearrange tenure common in descending order
mpi_state_summary <- mpi_state_summary[order(mpi_state_summary$Total_mpi_poor , decreasing=TRUE),]

#add cumulative column to the data frame
mpi_state_summary[,"cum_indiv_hectares"] <- cumsum(mpi_state_summary$Total_Indiv_sum_sum)

mpi_state_summary[,"cum_common_hectares"] <- cumsum(mpi_state_summary$Total_Common_sum_sum)

mpi_state_summary[,"cum_forest_hectares"] <- cumsum(mpi_state_summary$Total_Forest_sum_sum)

mpi_state_summary[,"cum_unaccounted_hectares"] <- cumsum(mpi_state_summary$Total_Unaccounted_sum_sum)

mpi_state_summary[,"cum_mpi_poor"] <- cumsum(mpi_state_summary$Total_mpi_poor)

#plot in descending order#assign order to prop variable
prop_order <-
  mpi_state_summary %>%
  arrange(desc(Total_mpi_poor)) %>%
  mutate(State = factor(State))

#plot decreasing pop and cumulative hectares 
scaleRight =4

mpi_max  = mpi_state_summary%>%mutate(State = factor(State, levels= prop_order$State, ordered =TRUE))%>%
  ggplot(aes(x = State, y = Total_mpi_poor))+ 
  geom_col(aes(x = State, y = Total_mpi_poor), fill = "#D3D3D3") + 
  geom_line(aes(y= cum_mpi_poor/scaleRight), group = 1, color = "black", size = 1.2)+ scale_y_continuous(name = "Multimdimensionally Poor Population (in Millions)", sec.axis = sec_axis(~.*scaleRight, name="Cumulative Multimdimensionally Poor Population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)), labels = scales::label_number(unit = "M", scale = 1e-6))+
  theme_classic()+ theme(axis.title = element_text(size = 8), axis.text.x = element_text(angle = 45, hjust = 1, size = 8))

mpi_max

options(scipen = 999)

```

Plot all variables of interest in one plot 

```{r message= FALSE, warning=FALSE, include =TRUE}

grid.arrange(population_max, mpi_max, nrow = 2)

```

(4) TOTAL HECTARES AVAILABLE FOR RESTORATION (as per land tenure):

In the following chunk of code, we plot the total population and cumulative hectares availabel for restoration at a district and state level.

```{r message = FALSE, warning = FALSE, include = TRUE}

#to plot cumulative hectares, we first need to order state summary in descending order 

#first add all the land categories 
state_summary$Total_hectares = state_summary$Total_Indiv_sum +
  state_summary$Total_Common_sum + state_summary$Total_Forest_sum 

#descending order to calculate cumulative hectares available
state_summary <- state_summary[order(state_summary$Total_hectares, decreasing=TRUE),]

state_summary[,"cum_total_hectares"] = cumsum(state_summary$Total_hectares)

#To plot every land tenure available in total hectares in a state, we make the table wide to long

#create a state summary
state_summary_2 = dat.summary%>%group_by(State)%>%summarise_at(.vars =
vars(Total_Indiv, Total_Common, Total_Forest, Total_Unaccounted,Total_Population),
.funs =c(sum = "sum"))

#reshape data for plotting
state_summary_long = reshape(state_summary_2, direction='long',
        varying=c('Total_Indiv_sum', 'Total_Common_sum', 'Total_Forest_sum', 'Total_Unaccounted_sum'),
        timevar= 'Land_Tenure',
       times=c('Individual', 'Common_NonForest', 'Forest', 'Unaccounted'),
        v.names= 'Total_Hectares',
        idvar=c('State', 'Total_Population_sum'))

#merge the state_summary and state_summary_long to get the total_hectares in the long table
state_summary_long = merge (state_summary_long, state_summary[c("State", "Total_hectares", "cum_total_hectares")], by.x = "State", by.y= "State")

#descending order
state_summary_long <- state_summary_long[order(state_summary_long$Total_hectares, decreasing=TRUE),]

#order for plot
prop_order <-
  state_summary%>%
  arrange(desc(Total_hectares)) %>%
  mutate(State = factor(State))

#plot
scaleRight = 7

state_total_plot = state_summary_long%>%
  mutate(State =factor(State, levels = prop_order$State, ordered = TRUE)) %>%
  ggplot(aes(x = State, y= Total_Hectares))+
  geom_col(aes(x = State, y = Total_Hectares, fill = Land_Tenure), position = position_stack(reverse = TRUE))+ 
  geom_line(aes(y= cum_total_hectares/scaleRight), group = 1, color = "black", size = 1.2)+ theme_classic()+ theme(axis.text.x = element_text(angle = 45, hjust = 1))+ scale_y_continuous(name = "Total hectares (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6), sec.axis = sec_axis(~.*scaleRight, name="Cumulative Hectares (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))) +
  scale_fill_manual(labels = c("Common land", "Forest land", "Individual land", "Unaccounted land"), values=c("#999933","#117733","#E69F00", "#D55E00")) + labs(fill = "Land tenure/cover", x = "State/ Union Territory")

state_total_plot

```

## QUESTION 2: 

When prioritizing restoration in a district (or state) based on (1) max population, (2) MPI and (3) climate vulnerability, (4) all three factors combined?

This analysis is carried out at the state level.

```{r message=FALSE, warning=FALSE, include=TRUE}

#create a district summary
#District summary of variables of interest
district_summary_2 = dat.summary%>%group_by(District_Name, State)%>%summarise_at(.vars =vars(Total_Indiv, Total_Common, Total_Forest, Total_Unaccounted, Total_Population, Total_area_in_hectares),
.funs =c(sum = "sum"))

#Combine this table with the mpi table
mpi_district_summary_2 = merge(district_summary_2, mpi_district[c("District", "State", "MPI_District", "Number_of_MPI_PeopleDistrict")], by.x = c("State", "District_Name"), by.y= c("State", "District"))

#make the table long

#reshape data for plotting
mpi_district_summary_2_long = reshape(mpi_district_summary_2, direction='long',
        varying=c('Total_Indiv_sum', 'Total_Common_sum', 'Total_Forest_sum', 'Total_Unaccounted_sum'),
        timevar= 'Land_Tenure',
       times=c('Individual', 'Common_NonForest', 'Forest', 'Unaccounted'),
        v.names= 'Total_Hectares',
        idvar=c('State', 'Total_Population_sum', 
                "Total_area_in_hectares_sum", "MPI_District",
                "Number_of_MPI_PeopleDistrict"))

#create a separate dataframe for each land tenure
for(i in unique(mpi_district_summary_2_long$Land_Tenure)) {
        name <- paste("tenure_", i, sep = "")
        assign(name, mpi_district_summary_2_long[mpi_district_summary_2_long$Land_Tenure==i,])}

#summarise at state level 
tenure_indiv_state = tenure_Individual%>%group(State)%<%
  
#cumulative hectares in each land tenure in descending order
#individual land
tenure_Individual <- tenure_Individual[order(tenure_Individual$Total_Hectares, decreasing=TRUE),]

tenure_Individual[,"cum_indiv_hectares"] <- cumsum(tenure_Individual$Total_Hectares)

#common land
tenure_Common_NonForest <- tenure_Common_NonForest[order(tenure_Common_NonForest$Total_Hectares, decreasing=TRUE),]

tenure_Common_NonForest[,"cum_common_hectares"] <- cumsum(tenure_Common_NonForest$Total_Hectares)

#forest land
tenure_Forest <- tenure_Forest[order(tenure_Forest$Total_Hectares, decreasing=TRUE),]

tenure_Forest[,"cum_forest_hectares"] <- cumsum(tenure_Forest$Total_Hectares)

#Histograms and pareto curves for the different types of land tenure
#order for plot
prop_order <-
  tenure_Individual%>%
  arrange(desc(Total_Hectares)) %>%
  mutate(State = factor(State))

#plot
scaleRight = 7

tenure_indiv_plot = tenure_Individual%>%
  mutate(State =factor(State, levels = prop_order$State, ordered = TRUE)) %>%
  ggplot(aes(x = State, y= Total_Hectares))+
  geom_col(aes(x = State, y = Total_Hectares, fill = "#E69F00"), position = position_stack(reverse = TRUE))+ 
  geom_line(aes(y= cum_indiv_hectares/scaleRight), group = 1, color = "black", size = 1.2)+ theme_classic()+ theme(axis.text.x = element_text(angle = 45, hjust = 1))+ scale_y_continuous(name = "Total hectares (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6), sec.axis = sec_axis(~.*scaleRight, name="Cumulative Hectares (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))) +
  #scale_fill_manual(labels = c("Common land", "Forest land", "Individual land", "Unaccounted land"), values=c("#999933","#117733","#E69F00", "#D55E00")) + labs(fill = "Land tenure/cover", x = "State/ Union Territory")

state_total_plot




```

## QUESTION 3:

What are the synergies and trade-offs between socio-economic and climate vulnerability factors when planning restoration according to land tenure regimes or according to total area available?

This analysis is dome at a district level.

```{r message= FALSE, warning=FALSE, include=TRUE}

#use the input dfs from the chunk of code above

#Tenure 1: Individual land 
individual_tradeoff_1 = 
  ggplot(tenure_Individual) + geom_jitter(data= tenure_Individual, aes(x=Number_of_MPI_PeopleDistrict, y=Total_Population_sum, size=Total_Hectares), color = "#E69F00", alpha= 0.5)+ theme_bw()+
  scale_y_continuous(name = "Total population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)) + scale_x_continuous(name="Multidimensionally poor population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))+   geom_vline(xintercept = 1750000, linetype="dashed") + geom_hline(yintercept = 3000000, linetype="dashed")
                                                                         
individual_tradeoff_1                                                     

#Tenure 1: Individual land 
individual_tradeoff_2 = 
  ggplot(tenure_Individual) + geom_jitter(data= tenure_Individual, aes(x=MPI_District, y=Total_Population_sum, size=Total_Hectares), color = "#E69F00", alpha= 0.5)+ theme_bw()+
  scale_y_continuous(name = "Total population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)) +
   geom_vline(xintercept = 0.2, linetype="dashed") + geom_hline(yintercept = 3000000, linetype="dashed")
#scale_x_continuous(name="Multidimensionally poor population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))
                                                                         
individual_tradeoff_2

#Tenure 2: Common land 
common_tradeoff_1 = 
  ggplot(tenure_Common_NonForest) + geom_jitter(data= tenure_Common_NonForest, aes(x=Number_of_MPI_PeopleDistrict, y=Total_Population_sum, size=Total_Hectares), color = "#999933", alpha= 0.5)+ theme_bw()+
  scale_y_continuous(name = "Total population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)) + scale_x_continuous(name="Multidimensionally poor population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))+   geom_vline(xintercept = 1750000, linetype="dashed") + geom_hline(yintercept = 3000000, linetype="dashed")
                                                                         
common_tradeoff_1

#Tenure 2: Common land 
common_tradeoff_2 = 
  ggplot(tenure_Common_NonForest) + geom_jitter(data= tenure_Common_NonForest, aes(x=MPI_District, y=Total_Population_sum, size=Total_Hectares), color = "#999933", alpha= 0.5)+ theme_bw()+
  scale_y_continuous(name = "Total population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)) + #scale_x_continuous(name="Multidimensionally poor population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))+ 
  geom_vline(xintercept = 0.2, linetype="dashed") + geom_hline(yintercept = 3000000, linetype="dashed")
                                                                         
common_tradeoff_2                                                        

#Tenure 3: Forest land 
forest_tradeoff_1 = 
  ggplot(tenure_Forest) + geom_jitter(data= tenure_Forest, aes(x=Number_of_MPI_PeopleDistrict, y=Total_Population_sum, size=Total_Hectares), color = "#117733", alpha= 0.5)+ theme_bw()+
  scale_y_continuous(name = "Total population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)) + scale_x_continuous(name="Multidimensionally poor population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))+   geom_vline(xintercept = 1750000, linetype="dashed") + geom_hline(yintercept = 3000000, linetype="dashed")

forest_tradeoff_1

forest_tradeoff_2 = 
  ggplot(tenure_Forest) + geom_jitter(data= tenure_Forest, aes(x=MPI_District, y=Total_Population_sum, size=Total_Hectares), color = "#117733", alpha= 0.5)+ theme_bw()+
  scale_y_continuous(name = "Total population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6)) + #scale_x_continuous(name="Multidimensionally poor population (in Millions)", labels = scales::label_number(unit = "M", scale = 1e-6))+  
  geom_vline(xintercept = 0.2, linetype="dashed") + geom_hline(yintercept = 3000000, linetype="dashed")

forest_tradeoff_2

grid.arrange(forest_tradeoff_1, common_tradeoff_1, individual_tradeoff_1, nrow= 3)


grid.arrange(forest_tradeoff_2, common_tradeoff_2, individual_tradeoff_2, nrow= 3)

```


Plot the proportion of land tenure (in hectares) in each state ordered by total population in each state.

```{r message = FALSE, warning= FALSE, include = TRUE}

#once again 
state_summary_2 = dat.summary%>%group_by(State)%>%summarise_at(.vars =
vars(Total_Indiv, Total_Common, Total_Forest, Total_Unaccounted,Total_Population),
.funs =c(sum = "sum"))

#reshape data for plotting
state_summary_long = reshape(state_summary_2, direction='long',
        varying=c('Total_Indiv_sum', 'Total_Common_sum', 'Total_Forest_sum', 'Total_Unaccounted_sum'),
        timevar= 'Land_Tenure',
       times=c('Individual', 'Common_NonForest', 'Forest', 'Unaccounted'),
        v.names= 'Total_Hectares',
        idvar=c('State', 'Total_Population_sum'))

#descending order
state_summary_long <- state_summary_long[order(state_summary_long$Total_Hectares, decreasing=TRUE),]

#Proportion of land available in each land tenure
state_summary_prop = state_summary_2%>%mutate(Prop_Indiv = (Total_Indiv_sum/
(Total_Indiv_sum+Total_Common_sum+Total_Forest_sum+Total_Unaccounted_sum))*100,
Prop_Common = (Total_Common_sum/
(Total_Indiv_sum+Total_Common_sum+Total_Forest_sum+Total_Unaccounted_sum))*100,
Prop_Unaccounted =(Total_Unaccounted_sum/
(Total_Indiv_sum+Total_Common_sum+Total_Forest_sum+Total_Unaccounted_sum))*100,
Prop_Forest = (Total_Forest_sum/
(Total_Indiv_sum+Total_Common_sum+Total_Forest_sum+Total_Unaccounted_sum))*100)

#reshape data for plotting
state_summary_prop = state_summary_prop[, -c(2:5)]

state_summary_prop_long = reshape(state_summary_prop, direction='long',
        varying=c('Prop_Indiv', 'Prop_Common', 'Prop_Forest', 'Prop_Unaccounted'),
        timevar= 'Land_Tenure',
       times=c('Individual', 'Common_NonForest', 'Forest', 'Unaccounted'),
        v.names= 'Total_Prop',
        idvar=c('State', 'Total_Population_sum'))

state_summary_prop_long <- state_summary_prop_long[order(state_summary_prop_long$Total_Prop, decreasing=TRUE),]

#plot in descending order#assign order to prop variable
prop_order <-
  state_summary_prop%>%
  arrange(desc(Prop_Common)) %>%
  mutate(State = factor(State))

#plot
state_prop_plot = state_summary_prop_long%>%
  mutate(State = factor(State, levels = prop_order$State, ordered = TRUE)) %>%
  ggplot(aes(x = State, y = Total_Prop, fill = Land_Tenure))+
  geom_col(position = position_stack(reverse = TRUE))+theme_bw()+theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  scale_fill_manual(labels = c("Common land", "Forest land", "Individual land", "Unaccounted land"), values=c("#999933","#117733","#E69F00", "#D55E00")) + labs(fill = "Land tenure/cover", x = "State/ Union Territory", y = "Proportion of Tenure")

state_prop_plot


```

UNUSED CODE 

#district level population figure
district_summary = dat.summary%>%group_by(District_Name,State)%>%summarise_at(.vars =
vars(Total_Indiv, Total_Common, Total_Forest, Total_Unaccounted,Total_Population),
.funs =c(sum = "sum"))

#rearrange tenure common in descending order
district_summary <- district_summary[order(district_summary$Total_Population_sum, decreasing=TRUE),]

#add cumulative column to the data frame
district_summary[,"cum_indiv_hectares"] <- cumsum(district_summary$Total_Indiv_sum)
district_summary[,"cum_common_hectares"] <- cumsum(district_summary$Total_Common_sum)
district_summary[,"cum_forest_hectares"] <- cumsum(district_summary$Total_Forest_sum)
district_summary[,"cum_unaccounted_hectares"] <- cumsum(district_summary$Total_Unaccounted_sum)
district_summary[,"cum_total_population"] <- cumsum(district_summary$Total_Population_sum)

#plot in descending order#assign order to prop variable
prop_order <-
  district_summary %>%
  arrange(desc(Total_Population_sum)) %>%
  mutate(District_Name = factor(District_Name))

prop_order$District_Name_2 <- factor(prop_order$District_Name, levels=unique(prop_order$District_Name))
#plot decreasing pop and cumulative hectares 
scaleRight = 5

population_max  = district_summary%>%mutate(District_Name = factor(District_Name, levels= prop_order$District_Name_2, ordered =TRUE))%>%ggplot(aes(x = District_Name, y = Total_Population_sum))+ 
  geom_col(aes(x = District_Name, y = Total_Population_sum, fill = State)) + 
    geom_line(aes(y= cum_total_population/scaleRight, group = 1)) + 
  #geom_line(aes(y= cum_indiv_hectares/scaleRight), group = 1, color = "#E69F00", size = 1.2)+ 
  geom_point(aes(y= cum_indiv_hectares/scaleRight), group = 1, color = "#E69F00")+ 
  geom_line(aes(y= cum_common_hectares/scaleRight), group = 1, color = "#999933", size = 1.2)+ 
  geom_point(aes(y= cum_common_hectares/scaleRight), group = 1, color = "#999933")+ 
  geom_line(aes(y= cum_forest_hectares/scaleRight), group = 1, color = "#117733", size = 1.2)+ 
  geom_point(aes(y= cum_forest_hectares/scaleRight), group = 1, color = "#117733")+
  scale_y_continuous(name = "Total Population", sec.axis = sec_axis(~.*scaleRight, name="Total Hectares"))+
  theme_classic()+ theme(axis.text.x = element_text(angle = 45, hjust = 1))

population_max

